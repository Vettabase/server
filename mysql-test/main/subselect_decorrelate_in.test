--echo #
--echo # MDEV-22534 Trivial correlation detection/removal for IN subqueries
--echo #

# The test uses optimizer trace:
--source include/not_embedded.inc
--source include/have_sequence.inc

--echo # Basic example
set optimizer_switch='materialization=on,firstmatch=off';
set optimizer_trace=1;
create table ten(a int primary key);
insert into ten values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a int, b int, c int);
insert into t1 select a,a,a from ten;
create table t2 select * from t1;

let $query=
select * from t1 where a in (select a from t2 where t1.b=t2.b);
eval explain $query;
eval $query;

let $query=
select * from t1 where (a, b) in (select a, b from t2);
eval explain $query;
eval $query;

--echo # Multiple equalities
let $query=
select * from t1 where a in (select a from t2 where t1.b=t2.b and t1.c=t2.c);
eval explain $query;
eval $query;

# Row item equality; requires extending `check_equality_for_exist2in()` to allow expr=expr to decorrelate (MDEV-31229)
let $query=
select * from t1 where a in (select a from t2 where (t1.b, t1.c)=(t2.b, t2.c));
eval explain $query;
eval $query;

# Row in left_expr
let $query=
select * from t1 where (a, b) in (select a, b from t2 where t1.c=t2.c);
eval explain $query;
eval $query;

let $query=
select * from t1 where a in (select a from t2 where t1.b=t2.b and t2.c+t2.b < 5);
eval explain $query;
eval $query;

let $query=
select * from t1 where a + b in (select a * c from t2 where t1.b=t2.b and t2.c+t2.b < 9);
eval explain $query;
eval $query;

--echo # Still correlated after the transformation / no materialization
let $query=
select * from t1 where a in (select a from t2 where t1.b=t2.b and t1.c < 5);
eval explain $query;
eval $query;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;

let $query=
select * from t1 where a in (select a from t2 where t1.a = t2.b and t2.c+t1.a < 9);
eval explain $query;
eval $query;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS 
from information_schema.OPTIMIZER_TRACE;

--echo # No transformation because of applicable conditions in subquery
let $query=
select * from t1 where a in (select a from t2 where t2.c+t1.a < 9);
eval explain $query;
eval $query;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS 
from information_schema.OPTIMIZER_TRACE;

drop table ten, t1, t2;

--echo # group by and having checks in the transformer; also not in

create table t1 (a1 int not null, b1 char(8) not null);
create table t2 (a2 int not null, b2 char(8) not null);

insert into t1 values (0, '2 - 00');
insert into t1 values (1, '2 - 01');
insert into t1 values (2, '2 - 02');

insert into t2 values (1, '2 - 01');
insert into t2 values (1, '2 - 01');
insert into t2 values (2, '2 - 02');
insert into t2 values (2, '2 - 02');
insert into t2 values (3, '2 - 03');

# skip on group by
let $query=
select * from t1 where a1 in (select count(*) from t2 where b1 = b2 group by b2);
eval explain $query;
eval $query;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS 
from information_schema.OPTIMIZER_TRACE;

# skip having
let $query=
select * from t2 where a2 in (select a1 from t1 where b1 = b2 having a1 > 0);
eval explain $query;
eval $query;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;

# not in
let $query=
select * from t1 where a1 not in (select a2 from t2 where b1 = b2);
eval explain $query;
eval $query;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;

drop table t1, t2;

--echo # check for aggregate function in the select items in the subquery; test adapted from main.delete_use_source_engines
create table t1 (c1 integer, c2 integer, c3 integer);
insert into t1(c1,c2,c3)
values (1,1,1),(1,2,2),(1,3,3),
       (2,1,4),(2,2,5),(2,3,6),
       (2,4,7),(2,5,8);
insert into t1 select c1+10,c2,c3+10 from t1;
insert into t1 select c1+20,c2+1,c3+20 from t1;
create view v1 as select * from t1 where c2=2;
let $c=
t1.c2 in ( select max(a.c2) from v1 a where a.c1 = t1.c1);
eval create table tmp as select * from t1 where $c;
drop table t1, tmp;
drop view v1;

--echo # check for subselect in left_expr; adapted from main.ps

create table t1 (a int, b int, c int);
create table t2 (x int, y int, z int);
create table t3 as select * from t1;
insert into t1 values (1,2,3),(4,5,6),(100,200,300),(400,500,600);
insert into t2 values (1,2,3),(7,8,9),(100,200,300),(400,500,600);
insert into t3 values (1,2,3),(11,12,13),(100,0,0),(400,500,600);

# scalar subselect - ok
let $query=
select * from t1 where (select a from t3 where t3.c=t1.c) in (select x from t2 where t1.c= t2.z);
eval explain $query;
eval $query;

# a row containing a subselect - ok
let $query=
select * from t1 where ((select a from t3 where t3.c=t1.c),b) in (select x, y from t2 where t1.c= t2.z);
eval explain $query;
eval $query;

# a single non-scalar subselect - skip transformation
let $query=
select * from t1 where (select a,b from t3 where t3.c=t1.c) in (select x,y from t2 where t1.c= t2.z);
eval explain $query;
eval $query;

drop table t1, t2, t3;

--echo # check that subselect is not a part of a union

# union
create table t1 (a1 char(8), b1 char(8));
create table t2 (a2 char(8), b2 char(8));
create table t3 (c1 char(8), c2 char(8));

insert into t1 values ('1 - 00', '2 - 00');
insert into t1 values ('1 - 01', '2 - 01');
insert into t1 values ('1 - 02', '2 - 02');

insert into t2 values ('1 - 01', '2 - 01');
insert into t2 values ('1 - 01', '2 - 01');
insert into t2 values ('1 - 02', '2 - 02');
insert into t2 values ('1 - 02', '2 - 02');
insert into t2 values ('1 - 03', '2 - 03');

insert into t3 values ('1 - 01', '2 - 01');
insert into t3 values ('1 - 01', '2 - 01');
insert into t3 values ('1 - 03', '2 - 03');


select * from t1 where a1 in
  ((select a2 from t2 where b1 = b2) union
   (select c2 from t3 where a1 = c1));

drop table t1, t2, t3;

--echo # all / any
create table t1 (a1 int, b1 int);
create table t2 (a2 int, b2 int);

insert into t1 values (0, 0);
insert into t1 values (1, 1);
insert into t1 values (3, 2);

insert into t2 values (1, 0);
insert into t2 values (1, 1);
insert into t2 values (2, 2);
insert into t2 values (3, 3);
insert into t2 values (3, 3);

# transformation applied because `= any` is synonym to `in`
let $query=
select * from t1 where a1 = any (select a2 from t2 where b1 = b2);
eval explain $query;
eval $query;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;

# transformation applied because `<> all` is synonym to `not in`
let $query=
select * from t1 where a1 <> all (select a2 from t2 where b1 = b2);
eval explain $query;
eval $query;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;

--echo # no transformation applied when no synonyms applied to any / all
select * from t1 where a1 >= all (select a2 from t2 where b1 = b2);
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS 
from information_schema.OPTIMIZER_TRACE;

select * from t1 where a1 <> any (select a2 from t2 where b1 = b2);
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS 
from information_schema.OPTIMIZER_TRACE;

drop table t1, t2;

--echo # fix NOT IN with null values
create table t1 (a1 int, b1 int);
create table t2 (a2 int, b2 int);

insert into t1 values (0, null), (1, 1);
insert into t2 values (0, 1), (1, null);

--echo # returns (0, null), (1, 1)
select * from t1 where not a1 in (select a2 from t2 where b1 = b2);
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;

--echo # returns empty
select * from t1 where not (a1, b1) in (select a2, b2 from t2);
--echo # returns (0, null), (1, 1)
select * from t1 where not (b1 is not null and (a1, b1) in (select a2, b2 from t2 where b2 is not null));

drop table t1, t2;

--echo # skip transformation when neither toplevel IN nor toplevel NOT IN; testcase adapated from main.subslect4
CREATE TABLE t1 ( a INT, b INT );
INSERT INTO t1 VALUES ( 1, NULL ), ( 2, NULL );
CREATE TABLE t2 ( c INT, d INT );
INSERT INTO t2 VALUES ( NULL, 3 ), ( NULL, 4 );
# not top level, upper_not is not top level
SELECT * FROM t1 WHERE a NOT IN ( SELECT c FROM t2 where b = d ) IS NULL;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;

# not top level, upper_not is null
SELECT * FROM t1 WHERE a IN ( SELECT c FROM t2 where b = d ) IS NULL;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS 
from information_schema.OPTIMIZER_TRACE;

drop table t1, t2;

--echo # 2nd ps execution / why we need to backup and restore the query arena; test also in main.subselect_sj2_mat

CREATE TABLE t1 ( c varchar(1));
INSERT INTO t1 VALUES ('r');
CREATE TABLE t2 ( a integer, b varchar(1), c varchar(1));
INSERT INTO t2 VALUES (1,'r','r');
CREATE OR REPLACE VIEW v1 AS SELECT * FROM t1;
PREPARE st2 FROM 'SELECT * FROM t2 WHERE a IN (SELECT a FROM v1 WHERE v1.c = t2.c)';
EXECUTE st2;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
EXECUTE st2;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;

drop table t1, t2;
drop view v1;

--echo # 2nd ps execution / why we skip the transformation if we are in a ps execution and eligible equalities intersects with the free list; test also in main.subselect4

CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (4),(6);
CREATE TABLE t2 (b INT);
INSERT INTO t2 VALUES (1),(8);
PREPARE st5 FROM "
SELECT * FROM t2
HAVING 0 IN (
  SELECT a FROM t1
  WHERE a IN (
    SELECT a FROM t1
    WHERE b = a
  )
)
";
EXECUTE st5;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
EXECUTE st5;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;

drop table t1, t2;

--echo # test case where the in subselect is wrapped in an Item_in_optimizer / the necessity to update the Item_in_optimizer; test also in main.subselect4

CREATE TABLE t1 (pk INT NOT NULL, i INT NOT NULL);
INSERT INTO t1 VALUES (0,10), (1,20), (2,30), (3,40);

CREATE TABLE t2a (pk INT NOT NULL, i INT NOT NULL, PRIMARY KEY(i,pk));
INSERT INTO t2a VALUES (0,0), (1,1), (2,2), (3,3);

let $query=
SELECT * FROM t1 WHERE (NULL, 1) NOT IN (SELECT t2a.i, t2a.pk FROM t2a WHERE t2a.pk = t1.pk);
eval EXPLAIN $query;
eval $query;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') AS JS
from information_schema.OPTIMIZER_TRACE;

drop table t1, t2a;

--echo # misc cases
# would-be empty leaf_tables if not for prior optimization, adapted from similar case for exists2in in main.subselect4
CREATE TABLE t2 (pk INT PRIMARY KEY, b INT);
INSERT INTO t2 VALUES (1,1),(2,7);
SELECT * FROM t2 AS alias1, t2 AS alias2
WHERE alias1.pk in ( SELECT 1 ) AND (alias2.pk = alias1.b )
ORDER BY alias1.b;
drop table t2;

# limit is not supported in IN subquery, so we don't have to worry about it
create table t1 (a1 char(8), b1 char(8));
create table t2 (a2 char(8), b2 char(8));

insert into t1 values ('1 - 00', '2 - 00');
insert into t1 values ('1 - 01', '2 - 01');
insert into t1 values ('1 - 02', '2 - 02');

insert into t2 values ('1 - 01', '2 - 01');
insert into t2 values ('1 - 01', '2 - 01');
insert into t2 values ('1 - 02', '2 - 02');
insert into t2 values ('1 - 03', '2 - 02');
insert into t2 values ('1 - 03', '2 - 03');

--error ER_NOT_SUPPORTED_YET
select * from t1 where a1 in (select a2 from t2 where b1 = b2 order by b2 desc limit 1, 2);

drop table t1, t2;

--echo # outer_exp has subquery
create table t1 (a1 int, b1 int);
create table t2 (a2 int, b2 int);

insert into t1 values (0, 0);
insert into t1 values (1, 1);
insert into t1 values (2, 2);

insert into t2 values (1, 0);
insert into t2 values (1, 1);
insert into t2 values (2, 2);
insert into t2 values (3, 2);
insert into t2 values (3, 3);

--error ER_SUBQUERY_NO_1_ROW
select * from t1 where a1 in
       (select a2 from t2 where
               a1 + (select b2 from t2) = b2);

let $query=
select * from t1 where a1 in
       (select a2 from t2 where
               (select a1 + b2 from t2 order by b2 limit 1) = a2);

eval explain $query;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
eval $query;

drop table t1, t2;

--echo # outer_exp has fulltext function
create table t1 (a1 int, b1 int);
create table t2 (a2 int, b2 text, fulltext(b2));

insert into t1 values (0, 0);
insert into t1 values (1, 1);
insert into t1 values (2, 0);

insert into t2 values (1, 'MariaDB overview');
insert into t2 values (1, 'https://mariadb.com/');
insert into t2 values (2, 'Foreign keys');
insert into t2 values (3, 'Indexes');
insert into t2 values (3, 'Triggers');

let $query=
select * from t1 where a1 in
       (select a2 from t2 where
               (select b1 + count(*) from t2 where
                       match(b2) against('mariadb')) = a2);
# with ps-protocol the count(0) which is an Item_aggregate_ref is in
# the runtime arena causing skipping the decorrelation
--disable_ps_protocol
eval explain $query;
--enable_ps_protocol
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
eval $query;

drop table t1, t2;

--echo # type mismatch leading to no materialization after transformation
create table t1 (a1 int, b1 int);
create table t2 (a2 int);

insert into t1 values (0, 0);
insert into t1 values (1, 1);
insert into t1 values (2, 2);

insert into t2 values (1);
insert into t2 values (1);
insert into t2 values (2);
insert into t2 values (3);
insert into t2 values (3);

alter table t2 add b2 varchar(32);
let $query=
select * from t1 where a1 in (select 1 from t2 where b1 = b2);
eval explain $query;
eval $query;
select 
  json_detailed(json_extract(trace, '$**.join_optimization.steps[*].transformation')) as JS 
from information_schema.OPTIMIZER_TRACE;

drop table t1, t2;

--echo # non-semijoin materialization
create table ten(a int);
insert into ten values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);

create table one_h(a int);
insert into one_h select A.a + B.a* 10 from ten A, ten B;

create table ten_k(a int primary key);
insert into ten_k select A.a + B.a* 100 from one_h A, one_h B;

create table t1 (a int, b int, c int );

insert into t1 select a, a, a from one_h;

create table t2 (a int, b int, c int );
insert into t2  select a,a,a from ten_k;

explain select * from t1 where 1 in (select 1 from t2 where t2.a=t1.a and t2.b=t1.b) or t1.c<333;
select 
  json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;

drop table ten, one_h, ten_k, t1, t2;

--echo #
--echo #
--echo #
create table t1 ( a int, b int, c int);
insert into t1 select seq, seq, seq from seq_1_to_10;
create table t2 ( x int, y int, z int);
insert into t2 select seq, seq, seq from seq_1_to_10;

insert into t1 values
( NULL ,   12 ,   12 ),
(   12 , NULL ,   12 ),
( NULL ,   13 ,   13 ),
(   13 , NULL ,   13 ),
(   21 ,   21 ,   21 ),
(   22 ,   22 ,   22 ),

(   12 ,   12 ,   12 ),
(   22 , NULL ,   22 ),
( NULL ,   21 ,   21 ),
(   23 , NULL ,   23 ),
( NULL ,   23 ,   23 );

create table one(w int);
insert into one values (1);

alter table t2 add key(x);
alter table t2 add key(y);
set @tmp=@@optimizer_switch, optimizer_switch='materialization=off';

--echo # This will not show full-scan-on-null-key:
--source include/explain-no-costs.inc
explain format=json 
select * from t1 
where t1.a not in (select t2.x from one,t2 ignore index(x) where t1.b=t2.y and t2.z=33);

--echo # This will show full-scan-on-null-key:
--source include/explain-no-costs.inc
explain format=json 
select * from t1 
where t1.a not in (select t2.x from one,t2 ignore index(y) where t1.b=t2.y and t2.z=33);

drop table one,t1,t2;
