#
# MDEV-22534 Trivial correlation detection/removal for IN subqueries
#
# Basic example
set optimizer_switch='materialization=on,firstmatch=off';
set optimizer_trace=1;
create table ten(a int primary key);
insert into ten values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t1 (a int, b int, c int);
insert into t1 select a,a,a from ten;
create table t2 select * from t1;
explain select * from t1 where a in (select a from t2 where t1.b=t2.b);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	10	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	8	func,func	1	
2	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	10	
select * from t1 where a in (select a from t2 where t1.b=t2.b);
a	b	c
0	0	0
1	1	1
2	2	2
3	3	3
4	4	4
5	5	5
6	6	6
7	7	7
8	8	8
9	9	9
explain select * from t1 where (a, b) in (select a, b from t2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	10	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	8	func,func	1	
2	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	10	
select * from t1 where (a, b) in (select a, b from t2);
a	b	c
0	0	0
1	1	1
2	2	2
3	3	3
4	4	4
5	5	5
6	6	6
7	7	7
8	8	8
9	9	9
# Multiple equalities
explain select * from t1 where a in (select a from t2 where t1.b=t2.b and t1.c=t2.c);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	10	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	12	func,func,func	1	
2	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	10	
select * from t1 where a in (select a from t2 where t1.b=t2.b and t1.c=t2.c);
a	b	c
0	0	0
1	1	1
2	2	2
3	3	3
4	4	4
5	5	5
6	6	6
7	7	7
8	8	8
9	9	9
explain select * from t1 where a in (select a from t2 where (t1.b, t1.c)=(t2.b, t2.c));
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	10	
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	10	Using where; Start temporary; End temporary; Using join buffer (flat, BNL join)
select * from t1 where a in (select a from t2 where (t1.b, t1.c)=(t2.b, t2.c));
a	b	c
0	0	0
1	1	1
2	2	2
3	3	3
4	4	4
5	5	5
6	6	6
7	7	7
8	8	8
9	9	9
explain select * from t1 where (a, b) in (select a, b from t2 where t1.c=t2.c);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	10	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	12	func,func,func	1	
2	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	10	
select * from t1 where (a, b) in (select a, b from t2 where t1.c=t2.c);
a	b	c
0	0	0
1	1	1
2	2	2
3	3	3
4	4	4
5	5	5
6	6	6
7	7	7
8	8	8
9	9	9
explain select * from t1 where a in (select a from t2 where t1.b=t2.b and t2.c+t2.b < 5);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	10	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	8	func,func	1	
2	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	10	Using where
select * from t1 where a in (select a from t2 where t1.b=t2.b and t2.c+t2.b < 5);
a	b	c
0	0	0
1	1	1
2	2	2
explain select * from t1 where a + b in (select a * c from t2 where t1.b=t2.b and t2.c+t2.b < 9);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	10	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	12	func,func	1	Using where
2	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	10	Using where
select * from t1 where a + b in (select a * c from t2 where t1.b=t2.b and t2.c+t2.b < 9);
a	b	c
0	0	0
2	2	2
# Still correlated after the transformation / no materialization
explain select * from t1 where a in (select a from t2 where t1.b=t2.b and t1.c < 5);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	10	Using where
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	10	Using where; Start temporary; End temporary; Using join buffer (flat, BNL join)
select * from t1 where a in (select a from t2 where t1.b=t2.b and t1.c < 5);
a	b	c
0	0	0
1	1	1
2	2	2
3	3	3
4	4	4
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
["decorrelation", "materialization", "semijoin"]
explain select * from t1 where a in (select a from t2 where t1.a = t2.b and t2.c+t1.a < 9);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	10	
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	10	Using where; Start temporary; End temporary; Using join buffer (flat, BNL join)
select * from t1 where a in (select a from t2 where t1.a = t2.b and t2.c+t1.a < 9);
a	b	c
0	0	0
1	1	1
2	2	2
3	3	3
4	4	4
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS 
from information_schema.OPTIMIZER_TRACE;
JS
["decorrelation", "materialization", "semijoin"]
# No transformation because of applicable conditions in subquery
explain select * from t1 where a in (select a from t2 where t2.c+t1.a < 9);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	10	
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	10	Using where; Start temporary; End temporary; Using join buffer (flat, BNL join)
select * from t1 where a in (select a from t2 where t2.c+t1.a < 9);
a	b	c
0	0	0
1	1	1
2	2	2
3	3	3
4	4	4
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS 
from information_schema.OPTIMIZER_TRACE;
JS
["materialization", "semijoin"]
drop table ten, t1, t2;
# group by and having checks in the transformer; also not in
create table t1 (a1 int not null, b1 char(8) not null);
create table t2 (a2 int not null, b2 char(8) not null);
insert into t1 values (0, '2 - 00');
insert into t1 values (1, '2 - 01');
insert into t1 values (2, '2 - 02');
insert into t2 values (1, '2 - 01');
insert into t2 values (1, '2 - 01');
insert into t2 values (2, '2 - 02');
insert into t2 values (2, '2 - 02');
insert into t2 values (3, '2 - 03');
explain select * from t1 where a1 in (select count(*) from t2 where b1 = b2 group by b2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	3	Using where
2	DEPENDENT SUBQUERY	t2	ALL	NULL	NULL	NULL	NULL	5	Using where
select * from t1 where a1 in (select count(*) from t2 where b1 = b2 group by b2);
a1	b1
2	2 - 02
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS 
from information_schema.OPTIMIZER_TRACE;
JS
NULL
explain select * from t2 where a2 in (select a1 from t1 where b1 = b2 having a1 > 0);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	5	Using where
2	DEPENDENT SUBQUERY	t1	ALL	NULL	NULL	NULL	NULL	3	Using where
select * from t2 where a2 in (select a1 from t1 where b1 = b2 having a1 > 0);
a2	b2
1	2 - 01
1	2 - 01
2	2 - 02
2	2 - 02
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
NULL
explain select * from t1 where a1 not in (select a2 from t2 where b1 = b2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	3	Using where
2	DEPENDENT SUBQUERY	t2	ALL	NULL	NULL	NULL	NULL	5	Using where
select * from t1 where a1 not in (select a2 from t2 where b1 = b2);
a1	b1
0	2 - 00
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
["decorrelation", "materialization"]
drop table t1, t2;
# check for aggregate function in the select items in the subquery; test adapted from main.delete_use_source_engines
create table t1 (c1 integer, c2 integer, c3 integer);
insert into t1(c1,c2,c3)
values (1,1,1),(1,2,2),(1,3,3),
(2,1,4),(2,2,5),(2,3,6),
(2,4,7),(2,5,8);
insert into t1 select c1+10,c2,c3+10 from t1;
insert into t1 select c1+20,c2+1,c3+20 from t1;
create view v1 as select * from t1 where c2=2;
create table tmp as select * from t1 where t1.c2 in ( select max(a.c2) from v1 a where a.c1 = t1.c1);
drop table t1, tmp;
drop view v1;
# check for subselect in left_expr; adapted from main.ps
create table t1 (a int, b int, c int);
create table t2 (x int, y int, z int);
create table t3 as select * from t1;
insert into t1 values (1,2,3),(4,5,6),(100,200,300),(400,500,600);
insert into t2 values (1,2,3),(7,8,9),(100,200,300),(400,500,600);
insert into t3 values (1,2,3),(11,12,13),(100,0,0),(400,500,600);
explain select * from t1 where (select a from t3 where t3.c=t1.c) in (select x from t2 where t1.c= t2.z);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	4	
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	4	Using where; Start temporary; End temporary; Using join buffer (flat, BNL join)
2	DEPENDENT SUBQUERY	t3	ALL	NULL	NULL	NULL	NULL	4	Using where
select * from t1 where (select a from t3 where t3.c=t1.c) in (select x from t2 where t1.c= t2.z);
a	b	c
1	2	3
400	500	600
explain select * from t1 where ((select a from t3 where t3.c=t1.c),b) in (select x, y from t2 where t1.c= t2.z);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	4	
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	4	Using where; Start temporary; End temporary; Using join buffer (flat, BNL join)
2	DEPENDENT SUBQUERY	t3	ALL	NULL	NULL	NULL	NULL	4	Using where
select * from t1 where ((select a from t3 where t3.c=t1.c),b) in (select x, y from t2 where t1.c= t2.z);
a	b	c
1	2	3
400	500	600
explain select * from t1 where (select a,b from t3 where t3.c=t1.c) in (select x,y from t2 where t1.c= t2.z);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	4	
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	4	Using where; Start temporary; End temporary; Using join buffer (flat, BNL join)
2	DEPENDENT SUBQUERY	t3	ALL	NULL	NULL	NULL	NULL	4	Using where
select * from t1 where (select a,b from t3 where t3.c=t1.c) in (select x,y from t2 where t1.c= t2.z);
a	b	c
1	2	3
400	500	600
drop table t1, t2, t3;
# check that subselect is not a part of a union
create table t1 (a1 char(8), b1 char(8));
create table t2 (a2 char(8), b2 char(8));
create table t3 (c1 char(8), c2 char(8));
insert into t1 values ('1 - 00', '2 - 00');
insert into t1 values ('1 - 01', '2 - 01');
insert into t1 values ('1 - 02', '2 - 02');
insert into t2 values ('1 - 01', '2 - 01');
insert into t2 values ('1 - 01', '2 - 01');
insert into t2 values ('1 - 02', '2 - 02');
insert into t2 values ('1 - 02', '2 - 02');
insert into t2 values ('1 - 03', '2 - 03');
insert into t3 values ('1 - 01', '2 - 01');
insert into t3 values ('1 - 01', '2 - 01');
insert into t3 values ('1 - 03', '2 - 03');
select * from t1 where a1 in
((select a2 from t2 where b1 = b2) union
(select c2 from t3 where a1 = c1));
a1	b1
1 - 01	2 - 01
1 - 02	2 - 02
drop table t1, t2, t3;
# all / any
create table t1 (a1 int, b1 int);
create table t2 (a2 int, b2 int);
insert into t1 values (0, 0);
insert into t1 values (1, 1);
insert into t1 values (3, 2);
insert into t2 values (1, 0);
insert into t2 values (1, 1);
insert into t2 values (2, 2);
insert into t2 values (3, 3);
insert into t2 values (3, 3);
explain select * from t1 where a1 = any (select a2 from t2 where b1 = b2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	3	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	8	func,func	1	
2	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	5	
select * from t1 where a1 = any (select a2 from t2 where b1 = b2);
a1	b1
1	1
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
["decorrelation", "materialization", "semijoin"]
explain select * from t1 where a1 <> all (select a2 from t2 where b1 = b2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	3	Using where
2	DEPENDENT SUBQUERY	t2	ALL	NULL	NULL	NULL	NULL	5	Using where
select * from t1 where a1 <> all (select a2 from t2 where b1 = b2);
a1	b1
0	0
3	2
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
["decorrelation", "materialization"]
# no transformation applied when no synonyms applied to any / all
select * from t1 where a1 >= all (select a2 from t2 where b1 = b2);
a1	b1
1	1
3	2
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS 
from information_schema.OPTIMIZER_TRACE;
JS
NULL
select * from t1 where a1 <> any (select a2 from t2 where b1 = b2);
a1	b1
0	0
3	2
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS 
from information_schema.OPTIMIZER_TRACE;
JS
NULL
drop table t1, t2;
# fix NOT IN with null values
create table t1 (a1 int, b1 int);
create table t2 (a2 int, b2 int);
insert into t1 values (0, null), (1, 1);
insert into t2 values (0, 1), (1, null);
# returns (0, null), (1, 1)
select * from t1 where not a1 in (select a2 from t2 where b1 = b2);
a1	b1
0	NULL
1	1
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
["decorrelation", "materialization"]
# returns empty
select * from t1 where not (a1, b1) in (select a2, b2 from t2);
a1	b1
# returns (0, null), (1, 1)
select * from t1 where not (b1 is not null and (a1, b1) in (select a2, b2 from t2 where b2 is not null));
a1	b1
0	NULL
1	1
drop table t1, t2;
# skip transformation when neither toplevel IN nor toplevel NOT IN; testcase adapated from main.subslect4
CREATE TABLE t1 ( a INT, b INT );
INSERT INTO t1 VALUES ( 1, NULL ), ( 2, NULL );
CREATE TABLE t2 ( c INT, d INT );
INSERT INTO t2 VALUES ( NULL, 3 ), ( NULL, 4 );
SELECT * FROM t1 WHERE a NOT IN ( SELECT c FROM t2 where b = d ) IS NULL;
a	b
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
NULL
SELECT * FROM t1 WHERE a IN ( SELECT c FROM t2 where b = d ) IS NULL;
a	b
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS 
from information_schema.OPTIMIZER_TRACE;
JS
NULL
drop table t1, t2;
# 2nd ps execution / why we need to backup and restore the query arena; test also in main.subselect_sj2_mat
CREATE TABLE t1 ( c varchar(1));
INSERT INTO t1 VALUES ('r');
CREATE TABLE t2 ( a integer, b varchar(1), c varchar(1));
INSERT INTO t2 VALUES (1,'r','r');
CREATE OR REPLACE VIEW v1 AS SELECT * FROM t1;
PREPARE st2 FROM 'SELECT * FROM t2 WHERE a IN (SELECT a FROM v1 WHERE v1.c = t2.c)';
EXECUTE st2;
a	b	c
1	r	r
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
["decorrelation", "materialization", "semijoin"]
EXECUTE st2;
a	b	c
1	r	r
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
NULL
drop table t1, t2;
drop view v1;
# 2nd ps execution / why we skip the transformation if we are in a ps execution and eligible equalities intersects with the free list; test also in main.subselect4
CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (4),(6);
CREATE TABLE t2 (b INT);
INSERT INTO t2 VALUES (1),(8);
PREPARE st5 FROM "
SELECT * FROM t2
HAVING 0 IN (
  SELECT a FROM t1
  WHERE a IN (
    SELECT a FROM t1
    WHERE b = a
  )
)
";
EXECUTE st5;
b
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
["materialization", "semijoin"]
EXECUTE st5;
b
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
NULL
drop table t1, t2;
# test case where the in subselect is wrapped in an Item_in_optimizer / the necessity to update the Item_in_optimizer; test also in main.subselect4
CREATE TABLE t1 (pk INT NOT NULL, i INT NOT NULL);
INSERT INTO t1 VALUES (0,10), (1,20), (2,30), (3,40);
CREATE TABLE t2a (pk INT NOT NULL, i INT NOT NULL, PRIMARY KEY(i,pk));
INSERT INTO t2a VALUES (0,0), (1,1), (2,2), (3,3);
EXPLAIN SELECT * FROM t1 WHERE (NULL, 1) NOT IN (SELECT t2a.i, t2a.pk FROM t2a WHERE t2a.pk = t1.pk);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	4	Using where
2	DEPENDENT SUBQUERY	t2a	const	PRIMARY	PRIMARY	8	const,const	1	Using where; Using index; Full scan on NULL key
SELECT * FROM t1 WHERE (NULL, 1) NOT IN (SELECT t2a.i, t2a.pk FROM t2a WHERE t2a.pk = t1.pk);
pk	i
0	10
2	30
3	40
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') AS JS
from information_schema.OPTIMIZER_TRACE;
JS
["decorrelation", "materialization"]
drop table t1, t2a;
# misc cases
CREATE TABLE t2 (pk INT PRIMARY KEY, b INT);
INSERT INTO t2 VALUES (1,1),(2,7);
SELECT * FROM t2 AS alias1, t2 AS alias2
WHERE alias1.pk in ( SELECT 1 ) AND (alias2.pk = alias1.b )
ORDER BY alias1.b;
pk	b	pk	b
1	1	1	1
drop table t2;
create table t1 (a1 char(8), b1 char(8));
create table t2 (a2 char(8), b2 char(8));
insert into t1 values ('1 - 00', '2 - 00');
insert into t1 values ('1 - 01', '2 - 01');
insert into t1 values ('1 - 02', '2 - 02');
insert into t2 values ('1 - 01', '2 - 01');
insert into t2 values ('1 - 01', '2 - 01');
insert into t2 values ('1 - 02', '2 - 02');
insert into t2 values ('1 - 03', '2 - 02');
insert into t2 values ('1 - 03', '2 - 03');
select * from t1 where a1 in (select a2 from t2 where b1 = b2 order by b2 desc limit 1, 2);
ERROR 42000: This version of MariaDB doesn't yet support 'LIMIT & IN/ALL/ANY/SOME subquery'
drop table t1, t2;
# outer_exp has subquery
create table t1 (a1 int, b1 int);
create table t2 (a2 int, b2 int);
insert into t1 values (0, 0);
insert into t1 values (1, 1);
insert into t1 values (2, 2);
insert into t2 values (1, 0);
insert into t2 values (1, 1);
insert into t2 values (2, 2);
insert into t2 values (3, 2);
insert into t2 values (3, 3);
select * from t1 where a1 in
(select a2 from t2 where
a1 + (select b2 from t2) = b2);
ERROR 21000: Subquery returns more than 1 row
explain select * from t1 where a1 in
(select a2 from t2 where
(select a1 + b2 from t2 order by b2 limit 1) = a2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	3	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	8	func,func	1	Using where
2	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	5	
3	DEPENDENT SUBQUERY	t2	ALL	NULL	NULL	NULL	NULL	5	Using filesort
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
["decorrelation", "materialization", "semijoin"]
select * from t1 where a1 in
(select a2 from t2 where
(select a1 + b2 from t2 order by b2 limit 1) = a2);
a1	b1
1	1
2	2
drop table t1, t2;
# outer_exp has fulltext function
create table t1 (a1 int, b1 int);
create table t2 (a2 int, b2 text, fulltext(b2));
insert into t1 values (0, 0);
insert into t1 values (1, 1);
insert into t1 values (2, 0);
insert into t2 values (1, 'MariaDB overview');
insert into t2 values (1, 'https://mariadb.com/');
insert into t2 values (2, 'Foreign keys');
insert into t2 values (3, 'Indexes');
insert into t2 values (3, 'Triggers');
explain select * from t1 where a1 in
(select a2 from t2 where
(select b1 + count(*) from t2 where
match(b2) against('mariadb')) = a2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	3	
1	PRIMARY	<subquery2>	eq_ref	distinct_key	distinct_key	8	func,func	1	Using where
2	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	5	
3	DEPENDENT SUBQUERY	t2	fulltext	b2	b2	0		1	Using where
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
["decorrelation", "materialization", "semijoin"]
select * from t1 where a1 in
(select a2 from t2 where
(select b1 + count(*) from t2 where
match(b2) against('mariadb')) = a2);
a1	b1
2	0
drop table t1, t2;
# type mismatch leading to no materialization after transformation
create table t1 (a1 int, b1 int);
create table t2 (a2 int);
insert into t1 values (0, 0);
insert into t1 values (1, 1);
insert into t1 values (2, 2);
insert into t2 values (1);
insert into t2 values (1);
insert into t2 values (2);
insert into t2 values (3);
insert into t2 values (3);
alter table t2 add b2 varchar(32);
explain select * from t1 where a1 in (select 1 from t2 where b1 = b2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	3	Using where
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	5	Using where; Start temporary; End temporary; Using join buffer (flat, BNL join)
select * from t1 where a1 in (select 1 from t2 where b1 = b2);
a1	b1
select 
json_detailed(json_extract(trace, '$**.join_optimization.steps[*].transformation')) as JS 
from information_schema.OPTIMIZER_TRACE;
JS
[
    {
        "select_id": 2,
        "from": "IN (SELECT)",
        "to": "decorrelation",
        "is_correlated": false
    },
    {
        "select_id": 2,
        "from": "IN (SELECT)",
        "to": "materialization",
        "possible": false,
        "cause": "types mismatch"
    },
    {
        "select_id": 2,
        "from": "IN (SELECT)",
        "to": "semijoin",
        "converted_to_semi_join": true
    }
]
drop table t1, t2;
# non-semijoin materialization
create table ten(a int);
insert into ten values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table one_h(a int);
insert into one_h select A.a + B.a* 10 from ten A, ten B;
create table ten_k(a int primary key);
insert into ten_k select A.a + B.a* 100 from one_h A, one_h B;
create table t1 (a int, b int, c int );
insert into t1 select a, a, a from one_h;
create table t2 (a int, b int, c int );
insert into t2  select a,a,a from ten_k;
explain select * from t1 where 1 in (select 1 from t2 where t2.a=t1.a and t2.b=t1.b) or t1.c<333;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	100	Using where
2	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	10000	
select 
json_extract(trace, '$**.join_optimization.steps[*].transformation.to') as JS
from information_schema.OPTIMIZER_TRACE;
JS
["decorrelation", "materialization"]
drop table ten, one_h, ten_k, t1, t2;
#
#
#
create table t1 ( a int, b int, c int);
insert into t1 select seq, seq, seq from seq_1_to_10;
create table t2 ( x int, y int, z int);
insert into t2 select seq, seq, seq from seq_1_to_10;
insert into t1 values
( NULL ,   12 ,   12 ),
(   12 , NULL ,   12 ),
( NULL ,   13 ,   13 ),
(   13 , NULL ,   13 ),
(   21 ,   21 ,   21 ),
(   22 ,   22 ,   22 ),
(   12 ,   12 ,   12 ),
(   22 , NULL ,   22 ),
( NULL ,   21 ,   21 ),
(   23 , NULL ,   23 ),
( NULL ,   23 ,   23 );
create table one(w int);
insert into one values (1);
alter table t2 add key(x);
alter table t2 add key(y);
set @tmp=@@optimizer_switch, optimizer_switch='materialization=off';
# This will not show full-scan-on-null-key:
explain format=json 
select * from t1 
where t1.a not in (select t2.x from one,t2 ignore index(x) where t1.b=t2.y and t2.z=33);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "t1",
          "access_type": "ALL",
          "loops": 1,
          "rows": 21,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "!(<in_optimizer>((t1.a,t1.b),<exists>(subquery#2)) and t1.b is not null)"
        }
      }
    ],
    "subqueries": [
      {
        "query_block": {
          "select_id": 2,
          "cost": "COST_REPLACED",
          "having_condition": "trigcond(t2.x is null)",
          "nested_loop": [
            {
              "table": {
                "table_name": "one",
                "access_type": "system",
                "rows": 1,
                "filtered": 100
              }
            },
            {
              "table": {
                "table_name": "t2",
                "access_type": "ref",
                "possible_keys": ["y"],
                "key": "y",
                "key_length": "5",
                "used_key_parts": ["y"],
                "ref": ["func"],
                "loops": 1,
                "rows": 1,
                "cost": "COST_REPLACED",
                "filtered": 100,
                "index_condition": "t2.y is not null",
                "attached_condition": "t2.z = 33 and trigcond(trigcond(<cache>(t1.a) = t2.x or t2.x is null))"
              }
            }
          ]
        }
      }
    ]
  }
}
# This will show full-scan-on-null-key:
explain format=json 
select * from t1 
where t1.a not in (select t2.x from one,t2 ignore index(y) where t1.b=t2.y and t2.z=33);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "t1",
          "access_type": "ALL",
          "loops": 1,
          "rows": 21,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "!(<in_optimizer>((t1.a,t1.b),<exists>(subquery#2)) and t1.b is not null)"
        }
      }
    ],
    "subqueries": [
      {
        "query_block": {
          "select_id": 2,
          "cost": "COST_REPLACED",
          "having_condition": "trigcond(t2.x is null)",
          "nested_loop": [
            {
              "table": {
                "table_name": "one",
                "access_type": "system",
                "rows": 1,
                "filtered": 100
              }
            },
            {
              "full-scan-on-null_key": {
                "table": {
                  "table_name": "t2",
                  "access_type": "ref_or_null",
                  "possible_keys": ["x"],
                  "key": "x",
                  "key_length": "5",
                  "used_key_parts": ["x"],
                  "ref": ["func"],
                  "loops": 1,
                  "rows": 4,
                  "cost": "COST_REPLACED",
                  "filtered": 100,
                  "attached_condition": "t2.z = 33 and t2.y is not null and trigcond(trigcond(<cache>(t1.a) = t2.x or t2.x is null)) and <cache>(t1.b) = t2.y"
                }
              }
            }
          ]
        }
      }
    ]
  }
}
drop table one,t1,t2;
